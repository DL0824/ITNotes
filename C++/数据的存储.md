## 整形

### 原码

将多进制数直接换算成二进制数进行（最高位是符号）

### 反码

**正数：**反码 = 原码

**负数：**原码符号位不变，其它位依次按位取反即可

### 补码

正数：补码 = 原码

负数：补码 = 反码 + 1

```c++
/*32位操作系统*/

int a = 5;
//原码：  0000 0000 | 0000 0000 | 0000 0000 | 0000 0101
//反码：  0000 0000 | 0000 0000 | 0000 0000 | 0000 0101
//补码：  0000 0000 | 0000 0000 | 0000 0000 | 0000 0101

int b = -3;
//原码：  1000 0000 | 0000 0000 | 0000 0000 | 0000 0011
//反码：  1111 1111 | 1111 1111 | 1111 1111 | 1111 1100
//补码：  1111 1111 | 1111 1111 | 1111 1111 | 1111 1101
```

**整形数据以补码形式存储在计算机中，CPU只有加法器没有减法器，不能计算 5 - 3 只能计算 5 + (-3)**

## 大小端

![](E:\资料\图片\2[X6W2LG0$P5~TFV2PS3T85.png)

上图展示了a、b变量在内存中的存储形式(16进制格式)，观察发现变量在内存中实际的存储形式与计算得到的补码的16进制形式顺序相反，这是因为存储模式的原因

**大端：**数据的低位保存在内存的高地址中，数据的高位保存在内存的低地址中

**小端：**数据的低位保存在内存的低地址中，数据的高位保存在内存的高地址中

### 笔试题：判断当前机器大小端

```c++
#include <stdio.h>

//方案1：
int checkSys() {
    int i = 1;
    char c = (*(char *)&i);
    
    return c;
}

//方案2：
int checkSys() {
    union {
        int i;
        char c;
    }un;
    un.i = 1;
    return un.c;
}

int main() {
    int res = checkSys();
    
    if(res == 1) printf("小端\n");
    else printf("大端\n");
    
    return 0;
}
```

## 浮点型

**IEEE754规定任意一个二进制浮点数V可以表示位：**
$$
(-1)^S*M*2^E
$$

- $(-1)^S$表示符号位，当S = 0，V为正数；当S = 1，V为负数
- M表示有效数字，$1\le M <2$
- $2^E$表示指数位

**exp：**

十进制的5.0，写成二进制是101.0，即$1.01*2^2$。可以得出：S = 0，M = 1.01， E = 2。若为十进制的-5.0，不难推算S = 1，M = 1.01，E = 2

### 单精度浮点数float

最高一位是符号位S，接着8位是指数E，剩下的23位为有效数字M

### 双精度浮点数double

最高一位是符号位S，接着11位是指数E，剩下的52位为有效数字M

![image-20210128235326140](C:\Users\后面那人\AppData\Roaming\Typora\typora-user-images\image-20210128235326140.png)